## 线程间通信

需要着重掌握的技术点

- 使用wait/notify实现线程间的通信
- 生产者/消费者模式的实现
- 方法join的使用
- ThreadLocal类的使用



#### wait/nofify使用

wait()、notify()、notifyAll()都是Object类的方法.

wait()方法可以使调用该方法的线程释放共享资源的锁，然后从运行状态退出，进入等待队列，直到被再次唤醒。

notify()方法可以随机唤醒等待队列中等待同一共享资源的”一个“线程，并使该线程退出等待队列，进入可运行状态，也就是notify()方法仅通知”一个“线程”。

notifyAll()方法可以使所有正在等待队列中等待同一共享资源的“全部”线程从等待状态退出，进入可运行状态。此时，优先级最高的那个线程最先执行，但也有可能是随机执行，因为这要取决于JVM虚拟机的实现。

线程对象状态切换如下图所示。

![线程对象状态切换图](imgs\1.jpg)

<center>线程状态切换示意图</center>

每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程。一个线程被唤醒后，才会进入就绪队列，等待CPU的调度；反之，一个线程被wait后，就会进入阻塞队列，等待下一次被唤醒。

wait/notify 调用后，锁的释放情况：

- 当wait()方法被执行后，锁被自动释放
- 执行完notify()，notifyAll()方法，锁却不自动释放，直到当前线程执行结束菜释放锁。

等待通知 wait/notify 使用总结：

- 使用wait时切忌要使用在while循环内 [示例](condition/Run.java)

- wait被唤醒后，会继续往wait之后的代码执行，而不是重新从monitor同步块处执行